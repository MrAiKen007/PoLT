<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Nova pasta]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Nova pasta</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 14 Dec 2025 14:21:47 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 14 Dec 2025 14:21:46 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Whitepaper Tecnico v1]]></title><description><![CDATA[PoLT é um protocolo de consenso híbrido pensado para pagamentos offline + economia local, onde validadores locais (representantes comunitários) ganham poder de validação com base em Trust Score (reputação local) e colaboram com a cadeia global para evitar double-spend e manter segurança.Objetivos principais: Permitir pagamentos entre pares sem conexão contínua. Preservar segurança global ao sincronizar blocos locais. Incentivar participação social (voluntariado, serviços) como moeda social. Ser leve para dispositivos móveis e suportar comunicações Bluetooth / mesh / QR. Usuários (U) — portadores de wallets com chaves privadas. Validadores Locais (VL) — nós comunitários (p.ex. vendedores, ONGs, escolas) com boa Trust Score. Mininó (MN) — dispositivo móvel que cria e guarda transações locais. Bloco Local (LB) — agrupamento de transações offline assinado por um conjunto de validadores locais. Rede Global (RG) — L1/L2 principal que recebe e armazena LBs como provas. Oráculos de Confirmação (OC) — serviços (descentralizados) que verificam provas externas (ex: dados de energia, ações sociais). Ledger Global (GL) — blockchain global que registra hashes dos LBs e confirma transações finalizadas. Transação Offline (TO): tx_id = H(pubkey_sender || nonce || amount || timestamp || metadata) sender_pubkey, receiver_pubkey amount local_nonce (monotônico por wallet local) timestamp_local signature_sender Mini-bloco local (LB): lb_id = H(prev_lb_hash || timestamp || merkle_root(transactions) || validator_signatures) transactions[] (list of TO) validator_signatures[] (sig of each VL que aprovou o LB) attestation_metadata (local group id, geo-hash opcional) Entradas no Ledger Global:
registro: (lb_id, merkle_root, validator_commitment, sync_timestamp, global_signature)
Trust Score é numérico (por exemplo 0–10,000) e recalculado periodicamente.Fontes de aumento: transações validadas (peso leve) tempo de operação sem reporte de fraude (peso médio) avaliações P2P (votos positivos) validação de oráculos externos (p.ex. participação social) Penalidades: transações revertidas por double-spend taxas de disputa vencidas reports com evidência Fórmula base (exemplo):
TS_new = TS_old + α valid_tx + β uptime + γ positive_votes − δ fraud_penalties
(α,β,γ,δ parâmetros ajustáveis por governance)Trust Score é atestado por assinaturas de múltiplos nodes e colocado no perfil do validador. Sender cria TO, assina com chave privada. Sender transmite TO via Bluetooth/NFC/QR para Receiver. Receiver checa local_nonce + saldo local contabilizado (wallet offline mantém “estado provisório”). Um conjunto de ≥k validadores locais (por proximidade/participação) assinam a TO, formando prova local. k pode variar por segurança (p.ex. 3). TO entra no LB local e é dada confirmação local (wallets podem aceitar pagamento com confirmação local). Ao reconectar, o MN (ou VL) submete LB para Rede Global. Rede Global verifica: assinaturas dos validadores (e TS mínima), ausência de double-spend (checa nonces e histórico global), se ok → grava hash do LB no GL (finalidade). Se houver conflito (double-spend identificado), aplica regras de disputa (ver abaixo). Observação: até sincronização, estados são provisionais; aplicações podem decidir nível de confiança aceitável (ex: loja aceita com 1 validação; mercado exige LB gravado na rede).Mecanismos combinados: Local nonces: cada wallet offline mantém um contador monotônico. Validadores exigem nonce correto. Multi-sig local (k-of-n): exige assinatura de múltiplos VLs para cada TO; dificulta gasto duplicado por um único nó comprometido. Timeout &amp; lock: quando uma TO é assinada localmente, a wallet pode publicar um temporary lock na rede (pequena prova que ocupa um espaço no GL sem custo alto) — opcional. Reconciliation on sync: Ao receber LBs, RG checa para cada tx se já existe gasto globalmente. Conflitos: resolve por timestamp_global + Trust Score weight dos validadores; pode reverter transações menos confiáveis ou penalizar VLs culpados. Challenge window: janela (ex: 24–72h) após LB submission onde disputas podem ser abertas; provas e testemunhas (logs Bluetooth, receipts) são aceitas como evidência. Token nativo (POLT) funções: pagamento de taxas de sincronização recompensa para VLs (por validação e honestidade) staking para candidatar-se a VL comprar reputação/votes em governance Modelo: VL stake mínimo S_min para participar. Recompensa por LB validado = base_reward + fee_share. Penalidade: stake slashing quando fraude comprovada. Parte das taxas vai para fundo comunitário (governance local). Monetização para fundadores/operadores: reservas iniciais do token (vesting) taxas de integração com empresas/merchants venda de serviços de nó/hosting para regiões sem infraestrutura Principais ameaças: Sybil (criar muitos nós falsos) → mitigado por stake + verificação social + oráculos. Collusão de validadores locais → mitigado por k-of-n, penalidades e verificação externa. Reprodução de transações offline (replay) → nonces + timestamps + merkle proofs. Ataque de sincronização adversária → nós honestos com maior TS e oráculos escalonam. Falsificação de evidências → aceitar apenas provas assinadas criptograficamente (logs assinado, receipts). Boas práticas: usar ED25519 para assinaturas SHA-3/Keccak para hashing relógio seguro com drift mitigation (tolerância de tempo) usar oráculos descentralizados para dados externos quando necessário Parâmetros (k, S_min, slashing rates, challenge window) ajustáveis via DAO local/global. Governança multi-nível: decisões locais por comunidades; mudanças de protocolo por voto global ponderado por TS e stake. Wallet mobile: gerar tx offline, view provisional balance, sync LB. VL node: recebe TOs via BLE/mesh, verifica, assina, cria LB, submete. Sync API: endpoint para enviar LB ao RG; resposta com status (accepted / rejected / dispute). Explorer: view global de LBs e Trust Scores. Exemplos endpoints (simplificados): POST /lb/submit {lb, proof} -&gt; {status, lb_hash} GET /tx/{tx_id} -&gt; {status, confirmations, lb_hash} POST /dispute {evidence} -&gt; {status} Client / Wallet: React Native (mobile), libs: libsodium / tweetnacl (crypto) VL Node: lightweight Go / Rust binary (para baixo consumo) Comm channels: Bluetooth Low Energy, libp2p (mesh), QR fallback Global Chain: Substrate (Polkadot) ou TON/EVM-compatible as L1 — facilita criar L2 custom Oráculos: Chainlink type or decentralized relay Database local: SQLite (mobile) para ledger provisório Semana 0–4: especificação técnica + protótipo do formato de tx + wireframes da wallet. Semana 4–12: protótipo mobile que cria TOs e envia por BLE; simples VL em NodeJS que assina. Semana 12–20: mini-rede local (3 VLs) com LB creation e sincronização para um testnet L1 (Substrate local). Semana 20–28: mecanismo de Trust Score básico e UI de avaliação P2P. Semana 28–40: stress tests offline, ataques simulados, ajustes; criar docs e whitepaper público. Lançamento pilot: 1 comunidade/região (por exemplo, um bairro ou escola) por 6 meses. micropagamentos em mercados sem internet pagamentos escolares (cantina) economia local entre produtores e consumidores rurais programas sociais com distribuição de benefícios controlada por confiança ]]></description><link>whitepaper-tecnico-v1.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Whitepaper Tecnico v1.md</guid><pubDate>Sun, 14 Dec 2025 14:16:53 GMT</pubDate></item><item><title><![CDATA[Whitepaper L2 TON]]></title><description><![CDATA[Criar uma Layer-2 (rollup / payment chain) que execute o protocolo Proof of Local Trust (PoLT) — validação permissionless via mesh BLE, validação local por quorum (k, ex.:5), geração de Local Blocks (LB) com assinaturas agregadas (BLS threshold) e settlement (registro de merkle_root / agg_sig) na TON L1 para finalidade e interoperabilidade.
Objetivos principais: Pagamentos offline seguros e rápidos (micropagamentos). Validação permissionless, sem autoridade central. Finalidade econômica via ancoragem em TON (batching para reduzir custos).
(Referências TON: Blueprint / Tact / Jettons). [Mobile PoLT Mesh (BLE/libp2p)] &lt;-- gossip --&gt; [Validator Nodes (Rust/Go) local] | | v v Create LB (merkle_root + agg_sig BLS) -----&gt; [L2 Rollup Engine / Sequencer] | v Batch merkle_roots | v TON L1 (settlement) L3 (App / Mesh): wallet mobile (React Native), BLE/libp2p para gossip e sign requests. L2 (tuas regras PoLT): rollup/sidechain que mantém contabilidade, disputa, staking &amp; slashing, tokenomics. L1 (TON): registra batches (merkle_roots + metadata) como prova de existência/finalidade — usa Tact/Blueprint e jettons para integração. Transação offline (TO) — JSON (exemplo):{ "tx_id": "H(sender||nonce||amount||ts||meta)", "sender_pub": "0x..", "receiver_pub": "0x..", "amount": 1000000, "local_nonce": 42, "ts_local": 1690000000, "metadata": {"purpose":"purchase","merchant":"id"}, "sig_sender": "ED25519(...)"
}
sig_meta (assinatura BLE de validador):{ "device_hash": "H(device_pubkey)", "rssi": -67, "ts": 1690000001, "ephemeral_pub": "0x..", "sig": "ED25519(ephemeral_priv, tx_id || nonce || ts || rssi)"
}
Local Block (LB) — armazenamento local / merkle_root:{ "lb_id": "H(prev_lb_hash||merkle_root||ts||validators_commitment)", "txs": [...], "merkle_root": "0x...", "validators_meta": [ {device_hash, ephemeral_pub, sig_meta}, ... ], "agg_sig": "BLS_agg(...)", "submitted": false
}
Payload de ancoragem para TON (batch):{ "batch_id": "H(timestamp||chain_id||merkle_root_batch)", "merkle_root_batch": "0x...", "agg_sigs_commitment": "0x...", "meta": { "num_LBs": 12, "total_value": 1234500000 }
} Criação: Sender cria TO e envia via BLE ao Receiver. Broadcast de pedido de assinatura: Receiver gossipa SIGN_REQUEST com tx_id. Assinaturas locais: Qualquer nó da mesh que passar checagens automáticas (nonce, saldo provisório, rate-limit, prova proximidade) assina com chave efêmera e envia sig_meta. Quorum (k): Quando Receiver coleta ≥k sig_meta válidas (device_hash distintos e heurísticas ok), LB inclui a TX e calcula merkle_root. Agg_sig: as k participações formam um agg_sig BLS (threshold) para compressão/verificação on-chain. Bibliotecas BLS/WASM permitem isso em mobile/nodes. Temporary lock: gera-se lock local (prova compacta) para reduzir double-spend até sync. Gossip LB: LB é gossipado pela mesh (replicação local). Sync/Submit: qualquer node com internet submete batch(s) de merkle_roots/agg_sigs para L2/Sequencer; L2 valida e publica merkle_root_batch na TON (mensagem contract). Challenge window: após publicação na TON, abre-se janela (ex.: 48h) para disputas; provas aceitas = logs BLE assinados, receipts, testemunhas. Em caso de fraude, slashing é aplicado no L2. Validation policy (permissionless): Auto-sign via BLE para qualquer app com regras locais. Assinaturas só têm peso se device TS ≥ threshold or ephemeral checks pass. Quorum k (configurável): default urbano k=5; rural k=3 com restrições de valor. Selection / fairness: para tarefas como criação sequencer LB, usa VRF shuffle + TS-weight to choose aggregator / submitter (evita monopolização). Assinatura agregada: BLS threshold para reduzir footprint on-chain e simplificar verificação. Use implementações maduras (herumi/bls, noble-bls12-381, celo threshold libraries). Rate limits &amp; heuristics: cap signatures por device / periodo; detecção de padrões de emulação. Trust Score (TS): dispositivo inicia com TS baixo; aumenta com comportamento honesto (LBs confirmados sem disputa). Recompensas ponderadas por TS. Stake opcional para validadores de alto peso: um stake mínimo S_min para quem quer maior recompensa/privilege; slashing se fraude comprovada. PoW leve (opcional) para bootstrapping: puzzle barato para cada new device/day, caro em escala massiva. Temporary locks &amp; nonces combinados para reduzir janela prática de double-spend. Challenge window + evidências: verificação automática de logs BLE assinados e provas baseadas em merkle proofs; slashing automático se provas válidas. Essas camadas juntas tornam ataques Sybil/colusão economicamente caros e detectáveis. (Trade-off: introduz fricção inicial.)Token nativo L2: POLT (exemplo) — funções: taxas, staking, slashing, recompensas. Supply &amp; distribution (exemplo): Total 1,000,000,000 POLT 40% ecosystem / rewards (long vesting) 20% team/advisors (vesting) 20% community / pilots 20% treasury / partnerships Tax split (por LB / tx): 40% → validadores (pro rata por TS) 30% → submitter / sequencer 20% → dispute fund (insurance) 10% → governance pool / local community Staking &amp; slashing: validadores que suportam maior peso podem fazer stake; prova de fraude leva a slashing parcial. Micropayment economics: tiny fees para cada tx (rateable), locks reduzem necessidade de altas taxas — batching em TON reduz custo global. Registro/anchor: L2 sequencer envia transações a um contract na TON que registra merkle_root_batch e metadata (batch_id, agg_sig_commitment). Use Blueprint / Tact para escrever e deploy do contrato. Jettons: para token nativo ou integrações com TON wallets, adotar padrão Jetton (TEP) para compatibilidade com wallets TON (Tonkeeper, Tonhub etc.). Frequência de anchoring: configurar batching (ex.: a cada 5–15 min para rotina; daily para “ultimate” anchoring). Batch para Bitcoin é opcional para ultimate finality. TON dev stack: Blueprint (npm create ton), Tact docs/SDK. BLS / threshold libs: herumi/bls, celo threshold bls, noble-bls12-381, threshold-bls crates (Rust). Use wasm bindings para mobile JS. Mesh: libp2p (BLE + mesh), ou soluções orientadas para mobile + bluetooth stacks. Mobile: React Native + libsodium / tweetnacl para ED25519; wasm wrapper para BLS/threshold. L2 engine: pode ser um sequencer simples (Rust/Go) que valida agg_sig e mantém estado; rollup design (optimistic or zk approach) opcional dependendo de recursos. Testing / infra: Chainstack / local TON testnet for contract deploy &amp; testing. Semana 0–2: especificação de mensagens BLE, estrutura do LB, e wireframes wallet. Semana 2–8: protótipo mobile: criar TO, broadcast SIGN_REQUEST, coletar k sigs (simulador local). Implementação de chaves efêmeras. Semana 8–14: validator node (Rust/Go) que cria LB, gera agg_sig (use library BLS), gossip mesh e persistência local. Semana 14–20: sequencer L2 básico (testnet) que aceita merkle_root, aplica regras de disputa e guarda estado; contrato Tact/Blueprint na TON testnet que registra batches. Semana 20–30: piloto controlado (1 bairro) — medir latência, false positives/negatives, atacar com simulações Sybil, ajustar parâmetros (k, TTL, limits). Semana 30+: auditoria, auditoria de crypto (BLS), integração wallets TON, scale-up. Verificar implementação BLS/threshold (DKG seguro se necessário). Testes adversariais: Sybil, colusão local, replay, rush submit. Revisão do contract Tact (registro batches) e manejo de disputas. Proteções de privacidade (evitar gravação de geo exato em L1). // Receiver side
on_receive(TX_OFFER from sender): if wallet.provisional_balance &gt;= amount and nonce_ok: broadcast_mesh({type:"SIGN_REQUEST", tx_id, local_nonce}) sigs = [] while sigs.count &lt; k and timeout not passed: resp = wait(SIGN_RESPONSE) if valid_sig_meta(resp): sigs.append(resp) if sigs.count &gt;= k: agg_sig = BLS_aggregate(sigs.ephemeral_sigs) LB = create_local_block([tx], merkle_root([txs]), agg_sig, validators_meta) store(LB) create_temporary_lock(tx.sender, amount, TTL) gossip_mesh({type:"NEW_LB", LB}) // Sequencer / any node with internet
periodic(): batches = collect_unsubmitted_LBs(max_batch_size) merkle_root_batch = merkle_root(batches.merkle_roots) payload = {batch_id, merkle_root_batch, commitments} send_to_ton_contract(payload) mark_submitted(batches) % txs confirmadas localmente (k sigs) vs % finalizadas on-chain. Latência média para k sigs (segundos). % de disputas por 1000 LBs (indicador de fraude). Custo on-chain / tx (TON fees / batch). Eficácia anti-Sybil (número médio de devices honestos vs detectados). Implementar PoLT como L2 sobre TON é viável e pragmático: dá-te controle total sobre regras locais, aproveita ferramentas (Tact/Blueprint, Jettons, TON Connect) e mantém ancoragem segura na TON. A parte crítica é implementar corretamente BLS/threshold, regras anti-Sybil (TS, rate limits, PoW leve opcional) e um mecanismo de disputas robusto.]]></description><link>whitepaper-l2-ton.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Whitepaper L2 TON.md</guid><pubDate>Sun, 14 Dec 2025 14:16:47 GMT</pubDate></item><item><title><![CDATA[Validacao Bluetooth]]></title><description><![CDATA[ Ótimo para UX: baixa fricção — o celular apenas escuta e assina. Permite validação local em massa (vários aparelhos próximos podem assinar). Torna fácil pagamentos ponto-a-ponto em mercados/feiras. Sybil / bots BLE: alguém cria/emula muitos dispositivos BLE para assinar fraudes. Replay / duplicate spending: remetente cria várias transações offline gastando o mesmo saldo. Colusão local: comerciantes e dispositivos combinam pra validar transações inválidas. Falsificação de proximidade: GPS/RSSI podem ser forjados ou manipulados. Exploração de recompensa: scripts automatizados vão "ligar" milhares de validadores virtuais. k-of-n automáticas (ex.: k = 3) A assinatura só é válida se k dispositivos distintos assinarem. O processo continua automático — o app assina por si — mas exige múltiplas assinaturas para aceitar pagamento localmente. Chaves efêmeras + comprovação de posse Cada app gera chaves efêmeras (rotativas) para assinar encontros BLE. A prova da chave mestra só é revelada no sync para provar autenticidade sem expor privacidade. Prova de proximidade reforçada Não confies só no RSSI. Combine: RSSI + BLE timestamp + nonce trocado entre sender/receiver + curta janela temporal. Esses elementos entram na assinatura como metadata. Rate-limits e anti-bot heuristic Device cap: um dispositivo só pode assinar N txs por hora com recompensa plena; acima disso, recompensa decresce automaticamente. Heurísticas locais: comportamento anômalo (padrão de assinaturas em série, sempre nas mesmas coordenadas) reduz a confiança temporária. Trust Score bootstrap + penalidade Dispositivos novos começam com TS baixo; só recebem recompensa plena após prova de honestidade (ex.: 50 assinaturas confirmadas sem disputa). Slashing de reputação/stake quando a rede comprova conluio. Temporary lock / provisional balance Quando k assinaturas são coletadas, geramos um temporary lock (pequena prova compacta). Esse lock é o que previne uma segunda transação imediata — outras lojas veem o lock ao sincronizar parcialmente. Locks podem ser submetidos em batches à L1 (baixo custo). Submissão Merkle &amp; janela de challenge Validadores agregam txs em um LB; só o merkle_root vai pra chain quando sincronizam. Janela de disputa (p.ex. 24–72h) permite reversão e slashing com evidências. Incentivo antifraude Recompensa dividida: parte para validadores, parte para quem submete LB, parte para fundo de disputa. Limitar ganho por dispositivo. k = 3 assinaturas de dispositivos distintos. Rate limit: max 20 assinaturas recompensadas / dispositivo / dia. Lock TTL (tempo que uma temporary lock é considerado válido localmente) = 30–120 minutos (ajustável por comunidade). Janela de challenge = 48 horas por default. TS inicial = 0; recompensa plena depois de 50 confirmações honestas. ]]></description><link>validacao-bluetooth.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Validacao Bluetooth.md</guid><pubDate>Sun, 14 Dec 2025 14:16:43 GMT</pubDate></item><item><title><![CDATA[Regras de Seguranca]]></title><description><![CDATA[Qualquer app/dispositivo pode assinar automaticamente via BLE, mas a assinatura só tem peso se obedecer a regras que impedem Sybil, colusão e replay. Peso = capacidade de gerar agg_sig que torne a transação localmente confirmada. Verificação do nonce local do sender — rejeitar se nonce inválido. Checagem de saldo provisório (wallet offline) — garantia mínima de fundos. Rate-limit local — o dispositivo só assina N txs recompensadas por hora/dia. Prevenção replay — aceitar só tx_hash que não exista no cache local de 24–72h. Prova mínima de proximidade — incluir RSSI + timestamp + nonce trocado e assinado. Chave efêmera obrigatória — assinar com chave rotativa; relação efêmera→longterm só é provada na sync. Use três mecanismos simultâneos para dificultar criação massiva de identities:A) Trust Score leve (TS_bootstrap)
Novo dispositivo começa com TS baixo. TS sobe com comportamento honesto (txs assinadas que entram no GL sem disputa). TS baixa com disputas/slashing.
B) Rate limits + heurísticas Hard caps (e.g., 20 assinaturas recompensadas/dia). Heurísticas detectam padrões de emulação (mesmas coordenadas, mesma hora, assinatura idêntica). C) Proof-of-work/effort alternativo opcional
Para quem quer spamar: exigir um pequeno PoW (p.ex. puzzle leve) antes da primeira assinatura do dia — barato para humanos, caro em escala massiva.
Esses três em conjunto tornam bot-farms caras e detectáveis sem fechar a rede. Definir k mínimo (p.ex. k=5 padrão urbano). Exigir device diversity: os k assinantes devem ter device_id_hash distintos; não aceitar assinaturas de um único fabricante/emulador detectado. k pode ser dinâmico: se densidade baixa, baixar k (ex.: k=3) mas exigir TS mínimo mais alto + limites de valor transacionado. Usar threshold/BLS para agregar k assinaturas em 1 agg_sig (eficiente on-chain). Validadores só enviam agg_sig+merkle_root do LB à L1 quando sincronizam. Quando agg_sig com k assina, gerar temporary lock local (pequena prova com TTL, p.ex. 30–90 min). Locks são submetidos em batches para L1 (pequenas footprints) para avisar o mundo que saldo foi comprometido. Ao tentar outra tx, wallets verificam locks recebidos recentemente. Janela de challenge (ex.: 48h) depois que um LB é publicado. Em caso de disputa, aceitar provas: logs BLE assinados, receipts, testemunhas (outros devices). Penalizar validadores culpados com slashing de reputação e perda de recompensa. Slashing automático se provas criptográficas forem válidas. Recompensa dividida: exemplo prático 40% para validadores que assinaram (peso TS ponderado) 30% para quem submete o LB à rede global (incentiva sync) 20% para fundo de disputa / seguro (cobrir chargebacks) 10% para comunidade local (governance) Limitar ganho por dispositivo (daily cap) evita exploração. Validadores usam chaves efêmeras para assinaturas BLE; só provas necessárias são reveladas na sincronização. Não gravar localização precisa no GL — usar geo-hash grosseiro ou apenas prova de proximidade (RSSI/time) para evitar vazamentos. k padrão urbano = 5 k rural = 3 (com restrições de valor) Rate limit por device = 20 assinaturas recompensadas/dia Temporary lock TTL = 30–90 minutos Janela de challenge = 48 horas TS bootstrap: recompensa plena após 50 txs confirmadas sem disputa Se não há k suficientes, wallet mostra “esperando validação” ou oferece aceitar com k menor mas cobrando taxa extra/limite de valor. Merchants podem indicar um threshold local aceitável (por exemplo: aceitar txs com k=3 para compras &lt; X Kz). Ferramentas públicas para visualizar LBs, TS agregados e disputas ajudam a detectar padrões de abuso. Bots de auditoria descentralizados (curadores) podem sinalizar regiões com alto risco. Segurança ↑ com mais regras (k alto, TS, slashing) — mas UX pode degradar em locais de baixa densidade. Sistema permissionless + defenses probabilísticas (rate-limits, PoW leve, TS) é o melhor caminho para manter abertura sem instituição central. ]]></description><link>regras-de-seguranca.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Regras de Seguranca.md</guid><pubDate>Sun, 14 Dec 2025 14:16:38 GMT</pubDate></item><item><title><![CDATA[Introducao Inovacao]]></title><description><![CDATA[As blockchains tradicionais (como Bitcoin, Ethereum, TON, etc.) precisam de conexão constante pra: validar blocos, transmitir transações, e evitar gastos duplos (double spending). Então, o desafio é:
“Como permitir que duas pessoas troquem valor sem internet, e ainda assim a rede confie quando voltarem online?” O pagamento acontece localmente, via Bluetooth, NFC ou QR Code. A transação é registrada no dispositivo (com assinatura digital). Quando o usuário reconecta, a transação é enviada e validada pela rede. Problema: precisa garantir que o usuário não gaste o mesmo saldo duas vezes antes de reconectar. Cada região ou cidade tem um nó local que valida transações offline. Quando reconecta à blockchain principal, faz um “merge” dos blocos locais. Problema: exige um consenso híbrido (um entre usuários locais e outro global). O emissor e o receptor assinam uma prova de transação temporal. Essa prova tem validade curta (ex: 30 minutos). Quando sincroniza, a rede confirma se o token ainda é válido e não foi duplicado. Problema: complexidade técnica alta — precisa de um novo protocolo de sincronização e confiança.Esse protocolo teria de definir:Imagina um consenso Proof of Local Trust (PoLT): Cada comunidade local (bairro, vila, escola) tem validadores “sociais”. As transações acontecem offline entre eles. Quando reconectam, a blockchain global valida o hash local. Isso permitiria pagamentos offline sem precisar de banco, e com confiabilidade social e criptográfica.
Tu poderias criar a primeira L2 social descentralizada da África — isso seria histórico.]]></description><link>introducao-inovacao.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Introducao Inovacao.md</guid><pubDate>Sun, 14 Dec 2025 14:16:33 GMT</pubDate></item><item><title><![CDATA[Estrategia L2 TON]]></title><description><![CDATA[Se queres personalizar tudo mas lançar rápido e seguro, cria uma L2 (rollup / payment chain) que faça settlement e ancoragem na TON, usando as ferramentas nativas da comunidade (Tact / Blueprint SDK) e um modelo de ancoragem de estados (merkle_root) em TON. Isso te dá controle do protocolo PoLT na L2 e segurança/integração com o ecossistema TON. Mínimo de trabalho duplicado — aproveitas segurança, infra e wallets da TON enquanto tens liberdade de consensos e regras na L2. Ferramentas já maduras — TON tem suporte dev (Tact, Blueprint SDK, TON Connect) que facilita deploy e integração de contratos/jettons. Isso acelera protótipo. Existem já iniciativas L2 para TON (ex.: TAC usando tecnologia de Polygon) — isso mostra que arquitetura L2 sobre TON é viável e tem precedentes. Anchoring flexível — podes publicar merkle_roots/commitments na TON (batches) para garantir settlement e interoperabilidade. Isso permite PoLT local + finalidade TON. Não comece com uma L1 soberana (chain do zero) se teu objetivo é validar PoLT: custa tempo e dinheiro e atrasa adoção. Usa L2 primeiro; se escalares, migra pra chain própria (Substrate/Cosmos) depois. Linguagem de contratos TON: Tact / FunC (Tact + Blueprint SDK para deploy). L2 design: rollup/sidechain que gera LBs (Local Blocks) e submete merkle_root à TON (mensagens/tx) como prova/settlement. Veja padrões de L2 sobre TON. Auth &amp; wallets: TON Connect para integração de wallets e UX. Off-chain mesh + PoLT: app mobile (React Native) + libp2p/BLE para mesh; nodes leves em Rust/Go para assemblagem de LBs e BLS agg_sig. (essas escolhas já alinhadas com o protótipo PoLT que discutimos.) L3 (mobile PoLT mesh): BLE mesh recolhe txs, valida localmente (k-of-n), cria LB. L2 (tuas regras PoLT): execução, estado e tokenomics (token L2). L2 aceita LBs e processa disputas locais. Settlement na TON (L1): L2 submete batches (merkle_roots/agg_sigs) p/ TON para garantia e finality. Em L2 cria um token nativo (tipo Jetton na TON ou equivalente L2) para taxas, staking, slashing e incentivos a validadores locais. Para integração com TON, podes emitir Jettons ou usar bridging quando necessário. Mantém janela de challenge + slashing no nível L2. Batch e ancoragem periódica na TON provêem finalidade externa. Para ultimate finality (se precisares), podes opcionalmente ancorar parte dos batches em PoW (Bitcoin) conforme discutimos — híbrido. Prova de conceito (4–8 semanas): mobile wallet que cria txs + mesh BLE, validator node que junta k sigs e cria LB local. Testes locais. Integrar L2 testnet: construir um L2 simples (rollup) que aceita merkle_roots e processa disputas; use Tact/Blueprint para contratos de settlement na TON testnet. Pilot real (1 bairro): rodar com usuários reais, medir latência, ataques e ajustar parâmetros k, TTL, challenge window. Em paralelo, preparar documentação e audit. Implementação incorreta do agg_sig/BLS ou protocolos de dispute. Sybil/colusão local se não houver incentivos/slashing bem desenhados. Custos de anchoring em TON (fees) — mitigado por batching. ]]></description><link>estrategia-l2-ton.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Estrategia L2 TON.md</guid><pubDate>Sun, 14 Dec 2025 14:16:27 GMT</pubDate></item><item><title><![CDATA[Consenso k-of-n]]></title><description><![CDATA[ Uma transação offline só é considerada localmente confirmada se pelo menos 5 dispositivos distintos próximos assinarem o tx_hash. Cada assinatura é feita automaticamente pelo app via Bluetooth (chave efêmera). Isso por si só aumenta a resistência a ataques (um único dispositivo malicioso já não basta). Mas precisamos de camadas extras.Exigir que os 5 validadores venham de identidades distintas e idealmente com distância/assinatura RSSI variada. Não pode aceitar 5 assinaturas do mesmo IP/emulador.
Implementação prática: cada assinatura inclui device_id_hash + rssi + timestamp + nonce. rejeitar assinaturas com mesmo device_id_hash (ou muito semelhantes). Cada app gera chaves efêmeras rotativas (por exemplo, trocam diariamente). As chaves efêmeras são assinadas por uma chave de longo prazo do app (guardada no dispositivo). Ao sincronizar, só se revela prova da relação efêmera→long_term sem expor a private key. Em vez de enviar 5 assinaturas separadas para a chain, usa-se BLS threshold signatures: as 5 assinaturas combinam-se num único agg_sig. Vantagem: economia de espaço on-chain e verificação única. Cada dispositivo só pode assinar X txs recompensadas por hora/dia. Comportamentos anormais (muitas assinaturas desde mesmas coordenadas) reduzem temporariamente confiança. Quando a transação coleta k=5 assinaturas, gera-se um temporary lock (pequena prova assinada) que previne gasto imediato do mesmo saldo por outro vendedor local que reconcilie logo em seguida. Wallet mantém local_nonce monotônico e só permite nova tx se nonce avançou. Dispositivos têm TS inicial baixo; ganham TS com LBs honestos. Se um LB contiver fraude, os validadores que assinaram perdem parte do TS / recompensa. Após submissão do LB global, abrir uma janela (ex.: 48h) pra disputas. Se alguém provar double-spend, aplicar slashing. Sender cria tx e tx_hash. Sender envia via BLE ao Receiver. Receiver broadcast pedido de assinatura local com tx_hash + nonce. App dos dispositivos próximos (auto) verifica saldo provisório local e, se OK, assina tx_hash com chave efêmera e retorna sig_meta (device_hash, rssi, ts). Quando já tiver 5 sig_meta válidas (de device_hash distintos e rssi coerente), o Receiver marca a tx como locally confirmed e gera temporary_lock. Um nó local ou qualquer participante submete o LB (contendo a tx e agg_sig BLS) à Rede Global quando conectar. Rede Global verifica: agg_sig, TS dos validadores (mínimo), nonces globais; grava merkle_root do LB; janela de challenge abre. Fallbacks: aceitar k=3 em locais rurais com maior trust_score mínimo e menor valor transacionado. aceitar validação de trusted anchors (p.ex. pontos fixos como lojas grandes) se a região não tiver massa crítica — porém só como exceção configurável por comunidade. Parâmetro dinâmico: k pode ser ajustado por governance local (k=5 padrão em zonas urbanas; k=3 em zonas rurais). k = 5 (padrão urbano). Rate limit por device: 20 assinaturas recompensadas / dia. Temporary lock TTL: 30–90 minutos. Janela de challenge: 48 horas. TS mínimo para validators que participam em agg_sig: &gt; threshold_low (ex.: 100/1000). Segurança aumenta com k, mas UX piora (pode demorar mais pra encontrar 5 devices). Threshold signatures resolvem o custo on-chain, mas adicionam complexidade de implementação. Mecanismos anti-Sybil (TS, rate limits, opcional stake) introduzem alguma fricção no onboarding. ]]></description><link>consenso-k-of-n.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Consenso k-of-n.md</guid><pubDate>Sun, 14 Dec 2025 14:16:21 GMT</pubDate></item><item><title><![CDATA[Conceito PoLT]]></title><description><![CDATA[Proof of Local Trust (Prova de Confiança Local) é um tipo de consenso baseado na reputação e verificação social dentro de comunidades locais — físicas ou digitais — em vez de apenas poder computacional ou financeiro. Em vez de “quem tem mais dinheiro” (PoS) ou “quem minera mais rápido” (PoW),
o PoLT pergunta:
“Quem é mais confiável dentro da comunidade local para validar transações?”
Imagina que tua blockchain tem várias “sub-redes locais” (por bairro, cidade ou grupo).
Cada uma tem validadores escolhidos pela confiança da comunidade.Esses validadores: Registram transações mesmo offline (via Bluetooth, NFC ou mesh). Guardam as transações num mini-bloco local. Quando reconectam à internet, publicam esse bloco na cadeia global. A rede global verifica as assinaturas e reputação dos validadores antes de aceitar os dados. Cada usuário tem um índice de confiança (Trust Score) que aumenta com: transações válidas e confirmadas, votos positivos de outros usuários locais, tempo de atividade na rede. E diminui com:
fraudes, transações duplas, ou bloqueios não sincronizados. Esse “Trust Score” vira a base de poder de validação, substituindo o stake (PoS) ou o hashpower (PoW).Aqui está o fluxo resumido do PoLT: Transação offline — feita entre dois usuários próximos. Validação local — assinada por 3+ validadores da comunidade (com bom Trust Score). Mini-bloco local — guardado até reconexão. Sincronização global — blocos locais enviados à rede principal. Verificação global — consenso híbrido (PoLT + PoS) confirma que não há duplicação. Recompensa — validadores locais recebem tokens pelo serviço honesto. O PoLT permitiria: Pagamentos offline (sem internet constante); Economias comunitárias autônomas (cada bairro ou escola pode ter um nó local); Reputação social como ativo (a confiança passa a ter valor econômico); Inclusão financeira real (mesmo sem bancos ou Wi-Fi). Seria a primeira blockchain “socialmente descentralizada”,
onde as pessoas são o consenso.Com PoLT, tu poderias criar: uma L2 para micropagamentos offline (ideal pra África e regiões rurais); um protocolo de identidade e reputação (para DeFi, DAOs e apps sociais); até uma moeda social (usando confiança real como base de valor). ]]></description><link>conceito-polt.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Conceito PoLT.md</guid><pubDate>Sun, 14 Dec 2025 14:16:16 GMT</pubDate></item><item><title><![CDATA[Comparativo Seguranca Bitcoin]]></title><description><![CDATA[ O Bitcoin usa Proof of Work global massivo: custo energético e poder computacional tornam ataques de double-spend economicamente proibitivos. Num cenário local/mesh (50 celulares), não há esse custo alto — um atacante com muitos dispositivos/emuladores pode dominar quorums e fraudar. Portanto não dá para “copiar” literalmente a segurança do Bitcoin sem acrescentar uma fonte externa de custo (energia, stake, ou ancoragem em uma cadeia PoW/PoS). Anchoring (ancorar) os LBs numa cadeia PoW/PoS pública Submete o merkle_root do Local Block (LB) numa blockchain robusta (ex.: Bitcoin ou outra PoW/PoS). Enquanto o LB não estiver ancorado com X confirmações, a transação é provisória; ancoragem dá finalidade forte. Trade-off: custo (fees) e latência até confirmações. Adicionar custo econômico local (stake + slashing) Validadores devem bloquear tokens (stake). Se forem pegos em fraude via challenge, perdem stake. Torna ataques Sybil mais caros; não tão forte quanto PoW global, mas eficaz em economia local. Proof-of-Work leve por transação (hashcash híbrido) Cada tx requer um pequeno PoW (dificuldade baixa) para ser assinada/recompensada — barato para usuários, caro em escala massiva. Em conjunto com k-of-n assinaturas, dificulta bot farms. k-of-n + BLS + temporary locks + challenge window Já falado, continua essencial: exige múltiplas assinaturas distintas e cria janela para disputas e provas — reduz sucesso de fraude imediata. Oráculos e provas externas Usar sensores externos (p.ex. pontos fixos com hardware-rooted identity) ou oráculos que atestem eventos na área — tornam conluio local mais difícil. Hybrid model — “Local fast, global final” Aceita txs localmente com k signatures (pagamentos de baixo valor instantâneos). Para transações maiores, exige ancoragem em uma cadeia com forte segurança (Bitcoin/PoS) antes da finalidade completa. Implementa PoLT com k=5, BLS, locks, TS, rate-limits (já definido). Para finalidade forte: cada N LBs (ou LBs acima de threshold de valor) são ancorados numa cadeia pública. Para reduzir custo: agrupar LBs e publicar apenas merkle_root em batches. Usa stake + slashing para reduzir Sybil + PoW leve como barreira adicional para emulação em massa. Sim, dá para chegar perto da segurança do Bitcoin sem gastar tanta energia, combinando: custo econômico (stake/slashing), custo computacional marginal (PoW leve), k-of-n distribuído e BLS, ancoragem periódica em uma cadeia pública para finalidade forte. Sem algum desses custos externos, a rede local nunca será tão resistente quanto o Bitcoin contra um atacante bem financiado. ]]></description><link>comparativo-seguranca-bitcoin.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Comparativo Seguranca Bitcoin.md</guid><pubDate>Sun, 14 Dec 2025 14:16:11 GMT</pubDate></item><item><title><![CDATA[Arquitetura Mesh Offline]]></title><description><![CDATA[ Rede offline: dispositivos formam uma mesh P2P via BLE/libp2p (até ~50 nodes em área). Transações: criações P2P entre sender→receiver via BLE. Validação local: um subset dinâmica de dispositivos na mesh (eleitos automaticamente) assina a tx. Requer k assinaturas (p.ex. k=5). Agregação + bloco local: validadores agregam txs num Local Block (LB) e produzem um agg_sig (BLS threshold). Sync para online: assim que qualquer nó da mesh encontra internet, submete o LB (merkle_root + agg_sig) à blockchain global. Blockchain global: recomenda-se PoS (menos custo energético, finalidades rápidas) ou usar uma L1 compatível/EVM/Substrate para facilidade. BLE + libp2p (mesh). Chaves efêmeras + ED25519 (assinatura local) + BLS threshold para agregação on-chain. Wallet local com local_nonce e cache de locks. Mini-node (VL) leve em Rust/Go para validar e submeter LBs. Chain de destino: PoS L1 ou L2 (submeter merkle_root/agg_sig). Sender gera TX (tx_hash = H(sender_pub || nonce || amount || ts || meta)) e envia ao Receiver via BLE. Receiver broadcast na mesh um sign request com tx_hash + local_nonce. N dispositivos automáticos checam regras (saldo provisório, rate-limit, prova proximidade) e, se OK, assinam com chave efêmera e respondem com sig_meta (device_hash, rssi, ts, sig). Quando Receiver coleta ≥k sig_meta válidas e distintas, forma LB (insere TX) e cria agg_sig (threshold BLS) — LB tem merkle_root. Gera temporary_lock. LB fica salvo localmente; todos os nodes da mesh sincronizam LB entre si (gossip). Quando um node obtém internet, ele pega LBs não-sincronizados e submete (merkle_root + agg_sig + validator_commitments) à blockchain global via API. Rede global verifica agg_sig, valida nonces contra ledger e abre challenge window. Se tudo ok, grava hash do LB e confirma txs globalmente. Eleição automática por VRF (verifiable random function) + peso por Trust Score: Cada nó gera uma saída VRF em cada epoch; se VRF &lt; threshold(node_TS, epoch), o nó é candidato validador. Isso distribui validação ao acaso, mas favorece quem provou honestidade. Alternativa simples: seleção randômica por shuffle determinístico da lista de peers + pick first k. Nonce monotônico na wallet + checagem local. k assinaturas distintas + device_id_hash diversity check (não aceitar múltiplos sigs do mesmo device). Rate-limits por device e limitação de recompensa. Locks temporários (TTL curto) publicados em batch para chain (reduz double-spend). Janela de challenge (p.ex. 48 h) e slashing/reputational penalty se prova. Heurísticas anti-bot (assinaturas em massa do mesmo coordenador/geo-hash). BLS threshold para reduzir footprint on-chain. PoS é melhor aqui: menor custo, confirmações mais rápidas e mais fácil integrar slashing/reputação. PoW adiciona barreira energética e latência — não ajuda o offline use-case. Ideal: submeter LBs a uma PoS L1 (ou L2 rollup) que aceite provas compactas (merkle_root + agg_sig). // --- on Sender ---
tx = {sender_pub, receiver_pub, amount, local_nonce, ts}
tx_hash = H(tx)
send_ble(receiver_id, {type: "TX_OFFER", tx, tx_hash}) // --- on Receiver ---
on_receive(TX_OFFER): if wallet.provisional_balance &gt;= amount and nonce_ok: broadcast_mesh({type:"SIGN_REQUEST", tx_hash, nonce}) sigs = [] while sigs.count &lt; k and timeout not reached: wait incoming SIGN_RESPONSE if valid_sig(response): sigs.append(response) if sigs.count &gt;= k: agg_sig = BLS_aggregate(sigs) LB = create_local_block([tx], merkle_root(...), agg_sig, validators_meta) store_local(LB) create_temporary_lock(tx.sender, tx.amount, TTL) gossip_mesh({type:"NEW_LB", LB}) // --- on any Node with Internet ---
periodic_sync(): for each LB in local_storage not yet submitted: payload = {merkle_root: LB.merkle_root, agg_sig: LB.agg_sig, meta: LB.validators_meta} resp = submit_to_chain(payload) if resp.accepted: mark_confirmed(LB) else if resp.dispute: open_challenge_procedure(LB) // --- Validator auto-signing (BLE listener) ---
on_receive(SIGN_REQUEST): if passes_checks(nonce, rate_limit, proximity, local_cache): sig = sign_with_ephemeral_key(tx_hash) send_ble(originator, {type:"SIGN_RESPONSE", device_hash, rssi, ts, sig}) network size target: 50 nodes (ok). k (assinaturas) padrão urbano = 5. rate-limit por device = 20 assinaturas recompensadas/dia. temporary_lock TTL = 30–90 minutos. challenge window = 48 horas. stake opcional para acelerar reputação; mas permissionless por padrão. Prototipar wallet mobile (React Native) que cria txs e faz BLE gossip. Implementar listener simples (NodeJS/Go) que age como validator e testa coleta de k sigs. Testnet local: montar uma L1 Substrate/PoS local para submeter merkle_roots. Simular ataques Sybil/colusão para ajustar parâmetros. ]]></description><link>arquitetura-mesh-offline.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Arquitetura Mesh Offline.md</guid><pubDate>Sun, 14 Dec 2025 14:16:05 GMT</pubDate></item><item><title><![CDATA[Analise de Riscos]]></title><description><![CDATA[ Validadores por Bluetooth — usar celulares próximos para assinar transações é plausível e torna a validação verdadeiramente local. Recompensa distribuída (metade das taxas) — incentiva participação imediata e espalha valor pela rede local. Hash única por transação — ter um tx_hash imutável (hash de todos os campos da tx) é essencial: evita alterações do conteúdo da transação. Mesmo com um tx_hash imutável guardado localmente, nada impede que o mesmo remetente gere duas transações diferentes (com hashes diferentes) gastando o mesmo saldo em duas lojas distintas enquanto está offline. Ou seja: o hash protege a integridade da tx, mas não evita que o usuário gaste o saldo duas vezes — que é o problema real. Sybil attack — qualquer pessoa cria muitos “validadores” falsos (vários telefones/emuladores) e aprova fraudes. Colusão local — comerciantes combinam para aceitar e gravar transações falsas. Recompensa inflacionária / exploração — bots emularão milhares de dispositivos bluetooth para ganhar taxas. Privacidade — logs BLE mal desenhados podem vazar encontros e hábitos. Estado provisório ambíguo — quem confia que a transação “está ok” antes da sincronização global? Em vez de 1 validador, cada transação precisa de k assinaturas de validadores distintos (“k de n”), por exemplo k = 3. Isso reduz risco de um único nó malicioso.Permitimos validação por qualquer celular, mas aplicamos um filtro de unicidade para dificultar Sybil: Trust Score inicial baixo para novos validadores; recompensa pequena até prova de honestidade. Taxa decrescente: recompensa por validação diminui se o dispositivo valida muitas txs seguidas sem ganhar reputação. Opcional: hardware attestation (SafetyNet/WebAuthn) — mantém descentralização, mas dificulta criação massiva de identidades falsas (trade-off privacidade). Cada wallet offline mantém um local_nonce monotônico. Validadores só assinam se a nonce bater. Ao assinar, validadores geram um temporary lock (pequena prova que indica que aquela U gastou X) — esse lock é submetido em massa quando qualquer nó reconecta (pequena footprint on-chain). Locks ajudam a avisar outras lojas que o saldo está comprometido. Validadores locais juntam txs num Local Block (LB) e publicam apenas o hash/merkle_root na L1 quando reconectam. Isso mantém prova imutável com custo on-chain baixo. Após LB subir, existe uma janela de challenge (ex.: 24–72h) onde se pode abrir disputa. Se fraude for provada, os validadores que assinaram perdem parte do stake ou reputação (slashing). Aqui entra a penalidade que desencoraja conluio. Não dar 50% direto a qualquer dispositivo: dividir em camadas: 30% para os validadores que assinaram (dividido por TS ponderado), 10% para um fundo de disputa/segurança, 10% para a comunidade local (governança), 50% restante para quem submete o LB à rede global (ou para o ecossistema — acordo opcional). Limitar recompensa por dispositivo por período (rate limit). Validadores usam chaves efêmeras para assinar encontros Bluetooth e provam posse de chaves maiores somente ao subir LB, preservando privacidade. Sender cria TX (contendo sender_pubkey, receiver_pubkey, amount, local_nonce, timestamp) → tx_hash. Sender envia via BLE ao receiver. Receiver pede assinatura a validators próximos. ≥k validadores (com TS &gt; threshold) assinam o tx_hash com chaves efêmeras. Cada assinatura inclui prova de proximidade (timestamp BLE + metadata). Validadores atualizam balances provisórios e gravam tx no LB local. Recompensas são atribuídas provisoriamente. Um nó qualquer submete LB (merkle_root + validator_signatures) ao GL quando reconecta. Rede global verifica assinaturas, TS, ausência de double-spend global (via nonces e locks) e aceita/rejeita. Janela de disputa ativa. ]]></description><link>analise-de-riscos.html</link><guid isPermaLink="false">Projetos/ProofOfLocalTrust/Analise de Riscos.md</guid><pubDate>Sun, 14 Dec 2025 14:15:46 GMT</pubDate></item></channel></rss>